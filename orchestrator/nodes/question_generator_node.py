"""
Question Generator Node - generates blocking questions and creates questions.md file.
"""

import os
import time
import json
from typing import Optional, Any, Dict
import google.generativeai as genai
from google.api_core import exceptions as google_exceptions
from orchestrator.state import SharedState, add_open_question
from orchestrator.tools.spec_feature_tools import (
    read_all_constitution_files,
    read_template_file,
    read_spec_file,
    write_spec_file,
)

# Configuration
MODEL_NAME = "gemini-2.5-flash-lite"

def _ensure_api_configured() -> bool:
    """Ensures API is configured. Returns True if successful."""
    api_key = os.getenv("GOOGLE_API_KEY")
    if not api_key:
        raise ValueError(
            "GOOGLE_API_KEY environment variable is not set. "
            "Please set it in your .env file or environment."
        )
    genai.configure(api_key=api_key)
    return True

def _call_api_with_retry(chat, prompt: str, max_retries: int = 3) -> Optional[Any]:
    """Calls API with exponential backoff retry logic."""
    for attempt in range(max_retries):
        try:
            response = chat.send_message(prompt)
            return response
        except google_exceptions.ResourceExhausted as e:
            wait_time = 2 ** attempt
            print(f"Rate limit hit. Retrying in {wait_time}s... (attempt {attempt + 1}/{max_retries})")
            time.sleep(wait_time)
        except google_exceptions.ServiceUnavailable as e:
            wait_time = 2 ** attempt
            print(f"Service unavailable. Retrying in {wait_time}s... (attempt {attempt + 1}/{max_retries})")
            time.sleep(wait_time)
        except Exception as e:
            print(f"API Error: {e}")
            raise
    raise Exception(f"API call failed after {max_retries} retries")

def question_generator_node(state: SharedState) -> SharedState:
    """
    Question Generator Node - generates blocking questions and creates questions.md.
    """
    _ensure_api_configured()
    
    feature_name = state.get('feature_name')
    spec_path = state.get('spec_path', 'spec/')
    current_phase = state.get('phase', 'INTAKE')
    
    if not feature_name:
        return {"error_logs": [{"node": "question_generator", "error": "No feature_name in state."}]}
    
    print(f"[Question Generator] Generating questions for feature: {feature_name} (phase: {current_phase})")
    
    # Read specification files
    spec_content = read_spec_file(feature_name, 'spec', spec_path)
    plan_content = read_spec_file(feature_name, 'plan', spec_path)
    tasks_content = read_spec_file(feature_name, 'tasks', spec_path)
    existing_questions_content = read_spec_file(feature_name, 'questions', spec_path)
    
    # Read constitution
    try:
        constitution = read_all_constitution_files(spec_path)
    except Exception as e:
        print(f"Warning: Could not read constitution: {e}")
        constitution = ""
    
    # Read questions template
    questions_template = ""
    try:
        questions_template = read_template_file('questions.md', spec_path)
    except Exception as e:
        print(f"Warning: Could not read questions template: {e}")
    
    # Get existing open_questions from state (if any were already generated by spec_reviewer)
    open_questions = state.get('open_questions', []).copy()
    
    # Build prompt for generating structured questions
    prompt = f"""You are a Question Generator. Your task is to identify missing information and generate structured blocking questions.

CONSTITUTION (project rules - MUST comply):
{constitution}

SPECIFICATION FILES TO ANALYZE:

=== spec.md ===
{spec_content[:4000] if spec_content else "File not found or empty"}

=== plan.md ===
{plan_content[:4000] if plan_content else "File not found or empty"}

=== tasks.md ===
{tasks_content[:4000] if tasks_content else "File not found or empty"}

=== Existing questions.md ===
{existing_questions_content[:2000] if existing_questions_content else "None"}

ANALYSIS TASK:
1. Identify missing or ambiguous information that blocks correct specification/implementation
2. For each missing piece, generate a structured question
3. For each question, identify which parts of spec.md, plan.md, or tasks.md depend on the answer (cite specific sections)
4. Provide answer options if applicable

Output JSON format:
{{
  "questions": [
    {{
      "question": "text of the question",
      "dependencies": "which parts of specs depend on answer, e.g., 'spec.md §3.2, plan.md §2.1'",
      "options": ["option 1", "option 2"] or null if open-ended
    }}
  ],
  "summary": "brief summary of what information is missing"
}}

Focus on blocking questions only - information that MUST be known before proceeding with spec/plan/tasks.
"""

    # Create model and chat
    model = genai.GenerativeModel(model_name=MODEL_NAME)
    chat = model.start_chat()
    
    try:
        response = _call_api_with_retry(chat, prompt)
        response_text = response.text
        
        # Extract JSON from response
        if "```json" in response_text:
            response_text = response_text.split("```json")[1].split("```")[0]
        elif "```" in response_text:
            response_text = response_text.split("```")[1].split("```")[0]
        
        result = json.loads(response_text.strip())
        
        questions_data = result.get("questions", [])
        summary = result.get("summary", "")
        
        print(f"[Question Generator] Generated {len(questions_data)} questions")
        
        # Generate questions.md content
        questions_md_content = f"# Questions — {feature_name}\n\n"
        if summary:
            questions_md_content += f"**Summary:** {summary}\n\n"
        
        questions_md_content += "## Questions\n\n"
        
        # Process each question
        for i, q_data in enumerate(questions_data, 1):
            question_text = q_data.get("question", "")
            dependencies = q_data.get("dependencies", "")
            options = q_data.get("options")
            
            # Add to structured open_questions in state
            question_id = add_open_question(open_questions, question_text, options)
            
            # Format for questions.md
            questions_md_content += f"## Question {i}: {question_text}\n\n"
            questions_md_content += f"- **Dependencies**: {dependencies}\n"
            
            if options and len(options) > 0:
                options_str = ", ".join([f'"{opt}"' for opt in options])
                questions_md_content += f"- **Options**: {options_str}\n"
            else:
                questions_md_content += "- **Options**: (open-ended)\n"
            
            questions_md_content += "- **Status**: open\n"
            questions_md_content += "- **Answer**: (pending)\n\n"
        
        # Write questions.md file
        write_spec_file(feature_name, "questions", questions_md_content, spec_path)
        print(f"[Question Generator] Created questions.md with {len(questions_data)} questions")
        
        # Extract usage
        usage = response.usage_metadata
        token_update = {
            "input_tokens": usage.prompt_token_count,
            "output_tokens": usage.candidates_token_count,
            "total_tokens": usage.total_token_count
        }
        
        # Set phase to QUESTIONS_PENDING
        return {
            "phase": "QUESTIONS_PENDING",
            "open_questions": open_questions,
            "token_usage": token_update,
            "messages": [f"Question Generator: Created {len(questions_data)} blocking questions. Please answer them in questions.md or provide answers in your message."]
        }
        
    except json.JSONDecodeError as e:
        print(f"Question Generator JSON Parse Error: {e}")
        print(f"Response was: {response_text[:500]}")
        return {
            "error_logs": [{"node": "question_generator", "error": f"Invalid JSON response: {e}"}],
            "phase": "FAILED"
        }
    except Exception as e:
        print(f"Question Generator Error: {e}")
        return {
            "error_logs": [{"node": "question_generator", "error": str(e)}],
            "phase": "FAILED"
        }

def question_generator_router(state: SharedState) -> str:
    """
    Router for question generator - determines next step after generating questions.
    """
    current_phase = state.get('phase', 'INTAKE')
    
    # After generating questions, wait for user to answer
    if current_phase == "QUESTIONS_PENDING":
        print(f"[Question Generator Router] Questions generated. Waiting for user answers.")
        return "__end__"
    
    # If failed, end
    if current_phase == "FAILED":
        return "__end__"
    
    # Default: end
    return "__end__"

